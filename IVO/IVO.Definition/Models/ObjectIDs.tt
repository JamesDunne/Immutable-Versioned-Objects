<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension=".generated.cs" #><#
    var types = new[]
    {
        "CommitID",
        "TreeID",
        "BlobID",
        "TagID",
    };
#>
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Text;
using IVO.Definition.Errors;

namespace IVO.Definition.Models
{
<#
    for (int i = 0; i < types.Length; ++i)
    {
        if (i != 0)
        {
#>

<#
        }
#>
	[TypeConverter(typeof(<#= types[i] #>TypeConverter))]
    public struct <#= types[i] #> : IEquatable<<#= types[i] #>>
    {
        public const int ByteArrayLength = 20;
        public const int HexCharLength = ByteArrayLength * 2;

        private readonly byte[] _idValue;
        private int _quickHash;
        private string _toString;

        public <#= types[i] #>(byte[] value)
        {
            // Sanity check first:
            if (value.Length != ByteArrayLength) throw new ArgumentOutOfRangeException("value", String.Format("<#= types[i] #> value must be {0} bytes in length", ByteArrayLength));
            
            _idValue = value;
            _quickHash = BitConverter.ToInt32(_idValue, 0);
            _toString = _idValue.ToHexString(0, 20);
        }

        public static Maybe<<#= types[i] #>> Parse(string hexValue)
        {
            // Sanity check first:
            if (hexValue.Length != HexCharLength) return Maybe<<#= types[i] #>>.Nothing;

            byte[] tmp = new byte[ByteArrayLength];
            for (int i = 0; i < ByteArrayLength; ++i)
            {
                int v1 = deHex(hexValue[i * 2 + 0]);
                int v2 = deHex(hexValue[i * 2 + 1]);
                if (v1 == -1) return Maybe<<#= types[i] #>>.Nothing;
                if (v2 == -1) return Maybe<<#= types[i] #>>.Nothing;
                tmp[i] = (byte)((v1 << 4) | v2);
            }

            return new <#= types[i] #>(tmp);
        }

        public sealed class ParseError : ErrorBase
        {
            private string _message;

            internal ParseError(string message) { this._message = message; }
            internal ParseError(string format, params object[] args) : this(String.Format(format, args)) { }

            public override string Message { get { return this._message; } }
        }

        public static Either<<#= types[i] #>, ParseError> TryParse(string hexValue)
        {
            // Sanity check first:
            if (hexValue.Length != HexCharLength) return new ParseError("<#= types[i] #> must be {0} characters in length", HexCharLength);

            byte[] tmp = new byte[ByteArrayLength];
            for (int i = 0; i < ByteArrayLength; ++i)
            {
                int v1 = deHex(hexValue[i * 2 + 0]);
                int v2 = deHex(hexValue[i * 2 + 1]);

                if (v1 == -1) return new ParseError("<#= types[i] #> character position {0} has invalid hex character '{1}'", i * 2 + 0, hexValue[i * 2 + 0]);
                if (v2 == -1) return new ParseError("<#= types[i] #> character position {0} has invalid hex character '{1}'", i * 2 + 1, hexValue[i * 2 + 1]);

                tmp[i] = (byte)((v1 << 4) | v2);
            }

            return new <#= types[i] #>(tmp);
        }

        private static int deHex(char c)
        {
            if (c >= 'A' && c <= 'F') return (int)(c - 'A' + 10);
            if (c >= 'a' && c <= 'f') return (int)(c - 'a' + 10);
            if (c >= '0' && c <= '9') return (int)(c - '0');
            return -1;
        }

        public static explicit operator byte[](<#= types[i] #> id)
        {
            return id._idValue;
        }

        public static explicit operator <#= types[i] #>(byte[] hash)
        {
            return new <#= types[i] #>(hash);
        }
        
        public static bool operator ==(<#= types[i] #> a, <#= types[i] #> b)
        {
            return a.Equals(b);
        }

        public static bool operator !=(<#= types[i] #> a, <#= types[i] #> b)
        {
            return !a.Equals(b);
        }
        
        public override bool Equals(object obj)
        {
            return this.Equals((<#= types[i] #>)obj);
        }

        public bool Equals(<#= types[i] #> other)
        {
            if ((this._idValue == null) != (other._idValue == null)) return false;

            // Compare byte-by-byte:
            for (int i = 0; i < ByteArrayLength; ++i)
                if (this._idValue[i] != other._idValue[i]) return false;

            return true;
        }

        public override int GetHashCode()
        {
            return _quickHash;
        }

        public override string ToString()
        {
            if (_toString == null) return String.Empty;
            return _toString;
        }

        public string ToString(int firstLength = HexCharLength)
        {
            if (firstLength <= 0) throw new ArgumentOutOfRangeException("firstLength", String.Format("firstLength must be greater than 0 and less than or equal to {0}", HexCharLength));
            if (firstLength > HexCharLength) throw new ArgumentOutOfRangeException("firstLength", String.Format("firstLength must be greater than 0 and less than or equal to {0}", HexCharLength));
            if (_toString == null) return String.Empty;
            return _toString.Substring(0, firstLength);
        }

        public class Comparer : IComparer<<#= types[i] #>>
        {
            public int Compare(<#= types[i] #> x, <#= types[i] #> y)
            {
                for (int i = 0; i < ByteArrayLength; ++i)
                {
                    if (x._idValue[i] == y._idValue[i]) continue;
                    return x._idValue[i].CompareTo(y._idValue[i]);
                }
                return 0;
            }
        }
    }

    public sealed class <#= types[i] #>TypeConverter : TypeConverter
    {
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
        {
            if (typeof(string) == sourceType)
                return true;
            else
                return base.CanConvertFrom(context, sourceType);
        }

        public override object ConvertFrom(ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value)
        {
            string strValue = value as string;
            if (strValue != null)
				return <#= types[i] #>.Parse(strValue).Value;

            return base.ConvertFrom(context, culture, value);
        }

        public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
        {
            if (typeof(string) == destinationType)
                return true;
            else
                return base.CanConvertTo(context, destinationType);
        }

        public override object ConvertTo(ITypeDescriptorContext context, System.Globalization.CultureInfo culture, object value, Type destinationType)
        {
            if (typeof(string) == destinationType)
                return ((<#= types[i] #>)value).ToString();
            else
                return base.ConvertTo(context, culture, value, destinationType);
        }
    }
<#
    } // for (int i = 0; i < types.Length; ++i)
#>
}
